# 第4章 App内存优化
## 4-1 内存优化介绍及工具选择
    1.内存优化介绍
    2.内存优化工具选择
    
    背景介绍
        内存是大问题但缺乏关注
        压死骆驼的最后一根稻草
    内存问题
        内存抖动：锯齿状、GC导致卡顿
        内存泄漏：可用内存减少、频繁GC
        内存溢出：OOM、程序异常
    工具选择
        Memory Profiler
            实时图标展示应用内存使用量
            识别内存泄漏、抖动等
            提供捕获堆转储、强制GC以及跟踪内存分配的能力
            特点：方便直观
                  线下平时使用
        Memory Analyzer（MAT）
            强大的Java Heap分析工具，查找内存泄漏及内存占用
            生成整体报告、分析问题等
            线下深入使用
        LeakCanary
            自动内存泄漏检测
            线下使用
    总结
        内存问题及优化工具
## 4-2 Android 内存管理机制
    Java内存管理机制
        （1）方法区
        （2）虚拟机栈
        （3）本地方法栈
        （4）堆
        （5）程序计数器
        
        Java内存回收算法
            （1）标记-清楚算法
                .标记出所有需要回收的对象
                .统一回收所有被标记的对象
                特点：标记和清楚效率不高
                      产生大量不连续的内存碎片
            （2）复制算法
                .将内存划分为大小相等的两块
                .一块内存用完之后复制存活对象到另一块
                .清理另一块内存
                总结：实现简单，运行高效
                      浪费一半控件，代价大
            （3）标记-整理算法
                .标记过程与“标记-清楚”算法一样
                .存活对象往一端进行移动
                .清理其余内存
                特点：避免“标记-清除”算法导致的内存碎片
                      避免“复制”算法的空间浪费
            （4）分代收集算法
                .结合多种收集算法优势
                .新生代对象存活率低，复制
    Android内存管理机制
        内存弹性分配，分配值与最大值受具体设备影响
        OOM场景：内存真正不足、可用内存不足
        
        Dalvik与Art区别
            .Dalvik仅固定一种回收算法
            .Art回收算法可运行期选择（5.0后）
            .Art具备内存整理能力，减少内存空洞
            
        Low Memory Killer
            针对所有进程
            .进程分类：前台进程、可见进程、服务进程、后台进程、空进程
            .回收收益
            
    总结
        Java及Android的内存管理机制

### 内存抖动解决实战
    内存抖动介绍
        定义：内存频繁分配和回收导致内存不稳定
        表现：频繁GC、内存曲线呈锯齿状
        危害：导致卡顿、OOM
    疑问：为什么内存抖动会导致OOM
    解疑：频繁创建对象，导致内存不足及碎片（不连续）
          不连续的内存片无法被分配，导致OOM
    内存抖动解决实战
        使用Memory Profiler初步排查
    总结