# 第5章 App布局优化
## 5-1 Android绘制原理及工具选择
    绘制原理
        CPU负责计算显示内容
        GPU负责栅格化（UI元素绘制到屏幕上）
        16ms发出VSync信号出发UI渲染
        大多数的Android设备屏幕刷新频率：60hz
    优化工具
        Systrace
            .关注Frames
            .正常：绿色圆点，丢帧：黄色或红色
            .Alerts栏
        Layout Inspector
        
        Choreographer
            获取FPS,线上使用，具备实时性
            .Api 16之后
            .Choreographer.getInstance().postFrameCallback
    总结
## 5-2 Android布局加载原理
    背景介绍
        .知其然知其所以然
        .深入源码
        
    布局加载源码跟踪    
        setContentView -> LayoutInflater -> inflate -> getLayout(注意：该操作是ｉｏ操作)
        -> createViewFromTag -> Factory -> crateView -> 反射
        通过源码过程：
            .布局文件解析：IO流程
            .创建View对象：反射
    
    LayoutInflater.Factory介绍
        .LayoutInflater创建View的一个Hook
        .定制创建View的过程：全局替换自定义TextView等
    Factory与Factory2
        .Factory2继承于Factory
        .多了一个参数：parent
        
    总结
        .布局加载源码跟踪
        .LayoutInflater.Factory
## 5-3 优雅获取界面布局耗时
    常规方式
        背景:获取每个界面加载耗时
        实现：复写方法、手动埋点
    AOP/ArtHook
        .切Activity的setContentView
        @Around("execution(* android.app.Activity.setContentView(..))")
        
Aop实现方式如下：
```
    @Around("execution(* android.app.Activity.setContentView(..))")
    public void getSetContentViewTime(ProceedingJoinPoint joinPoint) {
        Signature signature = joinPoint.getSignature();
        String name = signature.toShortString();
        long time = System.currentTimeMillis();
        try {
            joinPoint.proceed();
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
        Log.i("PerformanceAop",name + " cost " + (System.currentTimeMillis() - time));
    }
```
ARTHook实现
    .切Activity的setContentView(课后作业)
    
    获取任一控件耗时   
        .低侵入性
        .LayoutInflater.Factory
```
LayoutInflaterCompat.setFactory2(getLayoutInflater(), new LayoutInflater.Factory2() {
            @Override
            public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {

                if (TextUtils.equals(name, "TextView")) {
                    // 生成自定义TextView
                }
                long time = System.currentTimeMillis();
                View view = getDelegate().createView(parent, name, context, attrs);
//                LogUtils.i(name + " cost " + (System.currentTimeMillis() - time));
                return view;
            }

            @Override
            public View onCreateView(String name, Context context, AttributeSet attrs) {
                return null;
            }
        });
```
    
## 5-4 异步Inflate实战
    背景介绍
        .布局文件读取慢：IO过程
        .创建View 慢：反射（比new 慢三倍）
        
        根本性的解决
        侧面缓解
    AsyncLayoutInflater
        简称异步inflate
            .WorkThread加载布局
            .回调主线程
            .节约主线程时间
        如何使用
            .导包：com.android.support:asynclayoutinflater
```
通过侧面的方式来缓解布局加载慢
new AsyncLayoutInflater(MainActivity.this)
                .inflate(R.layout.activity_main,
                        null,
                        new AsyncLayoutInflater.OnInflateFinishedListener() {
                            @Override
                            public void onInflateFinished(@NonNull View view, int i, @Nullable ViewGroup viewGroup) {
                                setContentView(view);
                                mRecyclerView = findViewById(R.id.recycler_view);
                                mRecyclerView.setLayoutManager(new LinearLayoutManager(MainActivity.this));
                                mRecyclerView.setAdapter(mNewsAdapter);
                                mNewsAdapter.setOnFeedShowCallBack(MainActivity.this);
                            }
                        });
```

    AsyncLayoutInflater
        .不能设置LayoutInflater.Factory（自定义解决）
        .注意View中不能有依赖主线程的操作
    
    总结
        AsyncLayoutInflater实战及
## 5-5 布局加载优化实战
## 5-6 视图绘制优化实战
## 布局优化模拟
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    